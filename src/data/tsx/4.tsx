import React from 'react';
import { Helmet } from 'react-helmet';
import './css/basic.css';

const One: React.FC = () => {
  return (
    <div className="container">
      <Helmet>
        <title>Jimmy Lin's Blog:區塊鏈的基礎知識與技術</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      </Helmet>
      <div className='title'>
        <h1>比特幣白皮書簡介</h1>
          <div className='time'>
            <img src="https://firebasestorage.googleapis.com/v0/b/jimmy-lin-blog.appspot.com/o/calendar.svg?alt=media&token=df753433-ce85-4b37-bd10-2c3864a16565"/>
            <a>2024年10月31日</a>
          </div>
          <div className='img'>
            <img src="https://firebasestorage.googleapis.com/v0/b/jimmy-lin-blog.appspot.com/o/BTC.png?alt=media&token=1d23fb49-dc65-4811-891f-4dddcf40f03e"/>
          </div>
          <h2>1.介紹</h2>
          <h4>網路支付都依賴第三方，大部分時間網路支付是良好的，但還是會有信任的問題，完全不可逆的交易是不可能的。我們需要的是一個基於密碼證明而不是信任的電子支付系統，允許任何兩個願意的一方直接相互交易，而不需要可信的第三方。我們提出了一種使用點對點分散式網路來解決雙花問題的方案時間戳伺服器產生交易時間順序的計算證明。只要誠實的節點共同控制比任何合作的攻擊者節點群組更多的 CPU 功率，系統就是安全的。</h4>
          <h2>2.交易</h2>
          <h4>電子貨幣定義為數位簽章的鏈條，每位擁有者通過簽署上一筆交易的哈希和下一位擁有者的公鑰來轉移貨幣。收款人可以驗證這些簽章來確認所有權的連續性。傳統上，為防止雙重支付，需要一個可信的中心（如鑄幣機構）來檢查每筆交易，並在每次交易後重新發行新幣。但這種模式依賴於中心機構的運營，類似於銀行，存在信任風險。我們需要一種方法讓收款人知道之前的擁有者沒有進行雙重支付。為此，交易必須公開發布，並需建立參與者對交易順序的共識系統，以便收款人能證明大多數節點認同該筆交易為最早的記錄。</h4>
          <h2>3.時間戳伺服器</h2>
          <h4>我們的解決方案從時間戳伺服器開始。時間戳伺服器的工作方式是對要加上時間戳的數據塊進行哈希運算，並廣泛發布該哈希值，比如在報紙或 Usenet 上發布。時間戳證明了數據在當時確實存在，因為只有存在的數據才能生成哈希。每個時間戳都包含前一個時間戳的哈希，形成一個鏈條，隨著新時間戳的加入，之前的時間戳得到了進一步加強。</h4>
          <h2>4.工作量證明(Proof-of-Work)</h2>
          <h4>為了在點對點基礎上實現分佈式時間戳伺服器，我們需要使用類似 Adam Back 的 Hashcash 的工作量證明系統，而不是依賴報紙或 Usenet 發布。工作量證明的過程涉及尋找一個值，當使用 SHA-256 哈希時，哈希值以一定數量的零位開始。所需的平均工作量與零位的數量成指數關係，並且可以通過執行單次哈希進行驗證。在我們的時間戳網絡中，我們通過不斷增加區塊中的隨機數（nonce），直到找到一個使區塊哈希符合零位要求的值。一旦花費了 CPU 努力滿足工作量證明，該區塊就不能被更改，否則必須重新進行工作。隨著後續區塊的鏈接，修改該區塊需要重新計算所有後續區塊的工作量。工作量證明還解決了多數決策中的代表性問題。如果多數基於「每個 IP 地址一票」，則任何能夠分配多個 IP 的人都能破壞這個機制。而工作量證明則本質上是「每個 CPU 一票」。多數決策由鏈中最長的區塊表示，因為它投入了最多的工作量。如果大多數 CPU 能力由誠實節點控制，則誠實鏈將增長得最快，超過任何競爭鏈。要修改過去的區塊，攻擊者必須重新計算該區塊及其後所有區塊的工作量，然後追上並超過誠實節點的工作。我們將稍後展示，隨著後續區塊的添加，較慢的攻擊者追趕的概率會指數下降。為了補償硬件速度的提高和隨時間變化的節點運行興趣，工作量證明的難度是通過移動平均來確定的，目標是每小時生成的平均區塊數。如果生成過快，難度將增加。</h4>
          <h2>5.網路運行</h2>
          <h3>網絡運行的步驟如下：</h3>
          <h4>1.新交易會廣播到所有節點。</h4>
          <h4>2.每個節點將新交易收集到一個區塊中。</h4>
          <h4>3.每個節點為其區塊尋找困難的工作量證明。</h4>
          <h4>4.當某個節點找到工作量證明後，會將該區塊廣播給所有節點。</h4>
          <h4>5.節點僅在所有交易有效且未被花費的情況下接受該區塊。</h4>
          <h4>6.節點通過開始創建鏈中的下一個區塊來表達對該區塊的接受，並使用接受的區塊的哈希作為前一個哈希。</h4>
          <h4>節點始終認為最長的鏈是正確的，並會繼續擴展它。如果兩個節點同時廣播不同版本的下一個區塊，有些節點可能會首先接收到其中一個。此時，它們會根據先接收到的區塊進行工作，但會保存另一個分支以防其變得更長。當找到下一個工作量證明時，將打破這種平局，較長的分支會被選擇；之前在另一個分支工作的節點將轉向較長的分支。新交易的廣播不必到達所有節點。只要它們能夠到達許多節點，就會在不久的將來進入區塊。區塊的廣播也能容忍丟失的消息。如果某個節點未收到某個區塊，當它接收到下一個區塊並意識到漏接了一個時，會請求該區塊。</h4>
          <h2>6.獎勵機制</h2>
          <h4>根據慣例，區塊中的第一筆交易是一筆特殊的交易，創建新幣並將其歸屬於區塊的創建者。這為節點支持網絡提供了獎勵，並為幣的初始分發提供了一種方式，因為沒有中央機構來發行它們。穩定地增加新幣的數量類似於金礦工人為了增加流通的黃金而耗費資源。在我們的情況下，所需的資源是 CPU 時間和電力。獎勵也可以通過交易手續費來資助。如果交易的輸出值小於其輸入值，則差額即為交易手續費，這會增加包含該交易的區塊的獎勵值。一旦進入流通的幣數達到預定數量，獎勵就可以完全轉向交易手續費，實現完全的無通脹。獎勵還可能鼓勵節點保持誠實。如果一位貪婪的攻擊者能夠聚集的 CPU 能力超過所有誠實節點，他必須在用這些資源來通過竊取支付來欺詐人們，或用來產生新幣之間做出選擇。他會發現遵循規則（這些規則使他比其他人獲得更多的新幣）比破壞系統及其自身財富的有效性更具利潤。</h4>
          <h2>7.回收磁碟空間</h2>
          <h4>一旦一枚幣的最新交易被足夠多的區塊埋藏，之前的已花費交易就可以被丟棄以節省磁碟空間。為了實現這一點而不破壞區塊的哈希，交易使用 Merkle 樹進行哈希，僅將樹根包含在區塊的哈希中。舊區塊可以通過刪除樹的分支來進行壓縮，內部哈希不需要儲存。一個沒有交易的區塊標頭大約為 80 字節。如果假設每 10 分鐘生成一個區塊，則每年將產生 80 字節 * 6 * 24 * 365 = 4.2MB 的數據。根據 2008 年的情況，電腦系統通常配備 2GB 的 RAM，而摩爾定律預測每年增長 1.2GB，因此即使必須將區塊標頭保存在內存中，存儲也不應成為問題。</h4>
          <h2>8.簡化支付驗證</h2>
          <h4>可以在不運行完整網絡節點的情況下驗證支付。用戶只需保留最長工作量證明鏈的區塊標頭副本，可以通過查詢網絡節點來獲取，直到他確信擁有最長鏈，並獲得將交易與其時間戳記的區塊連結的 Merkle 分支。他無法自行檢查交易，但通過將其鏈接到鏈中的某個位置，他可以看到網絡節點已經接受了該交易，且之後添加的區塊進一步確認了網絡的接受。因此，只要誠實的節點控制網絡，驗證是可靠的，但如果網絡被攻擊者壓倒則更易受到威脅。雖然網絡節點可以自行驗證交易，但簡化方法可能會被攻擊者製造的虛假交易欺騙，只要攻擊者能持續壓倒網絡。一種保護措施是當網絡節點檢測到無效區塊時接受警報，促使用戶的軟件下載完整區塊和相關的警報交易以確認不一致性。經常接收支付的企業可能仍希望運行自己的節點，以獲得更獨立的安全性和更快的驗證。</h4>
          <h2>9.價值的合併和拆分</h2>
          <h4>雖然可以單獨處理每一枚硬幣，但為每一分錢的轉帳進行單獨交易會很繁瑣。為了允許價值的拆分和合併，交易包含多個輸入和輸出。通常會有一個來自較大先前交易的單一輸入，或多個輸入合併較小的金額，最多會有兩個輸出：一個是支付的金額，另一個是如果有的話，將找零返回給發件人。需要注意的是，交易的扇出（即一個交易依賴於幾個交易，而這些交易又依賴於更多的交易）在這裡並不是問題。永遠不需要提取一個交易歷史的完整獨立副本。</h4>
          <h2>10.隱私</h2>
          <h4>傳統銀行模式通過限制信息訪問來實現一定程度的隱私，僅限於相關方和可信第三方。由於所有交易必須公開宣布，這種方法無法適用，但可以通過在其他地方中斷信息流來保持隱私，即保持公鑰的匿名性。公眾可以看到某人向某人發送了一定金額，但無法得知與任何人相關的具體信息。這類似於股票交易所公開的資訊，顯示個別交易的時間和金額，但不告知當事方。作為額外的防火牆，每次交易應使用一對新密鑰，以防止它們與共同擁有者鏈接。對於多輸入交易來說，某種程度的鏈接仍然是不可避免的，因為其輸入必然顯示由同一擁有者擁有。風險在於，如果某個密鑰的擁有者被揭露，鏈接可能會顯示出屬於同一擁有者的其他交易。</h4>
          <h2>11.計算</h2>
          <h4>我們考慮一名攻擊者試圖生成比誠實鏈更快的替代鏈的情景。即使這成功了，也不會使系統對任意更改開放，例如無中生有地創造價值或竊取從未屬於攻擊者的資金。節點不會接受無效的交易作為支付，誠實的節點也永遠不會接受包含它們的區塊。攻擊者只能嘗試更改他自己的交易，以取回他最近花費的資金。誠實鏈與攻擊者鏈之間的競爭可以被描述為二項隨機漫步。成功事件是誠實鏈延長一個區塊，增加其優勢 +1，失敗事件是攻擊者鏈延長一個區塊，減少差距 -1。攻擊者追趕的概率類似於賭徒破產問題。假設一名擁有無限信用的賭徒從赤字開始，並潛在地進行無限次試驗來達到盈虧平衡。我們可以計算他達到盈虧平衡的概率，或者攻擊者追趕上誠實鏈的概率，如下所示：</h4>
          <h4>p = 誠實節點找到下一個區塊的概率</h4>
          <h4>q = 攻擊者找到下一個區塊的概率</h4>
          <h4>qz = 攻擊者從落後 z 個區塊追趕的概率</h4>
          <img src='https://firebasestorage.googleapis.com/v0/b/jimmy-lin-blog.appspot.com/o/%E7%99%BD%E7%9A%AE%E6%9B%B8%E5%85%AC%E5%BC%8F.png?alt=media&token=592b6bf4-d5f5-4f47-b398-ec700a0dda65'></img>
          <h4>在假設 p&gt;q 的情況下，隨著攻擊者需要追趕的區塊數增加，概率會以指數方式降低。在不利的情況下，如果他在早期沒有幸運的進展，他的機會隨著進一步的落後變得微乎其微。</h4>
          <h3>交易接受者的等待時間</h3>
          <h4>現在我們考慮一名新交易的接受者需要等待多久，才能有足夠的信心相信發送者無法更改交易。我們假設發送者是想讓接受者相信他已付款一段時間，然後在過了一段時間後切換回自我支付。當這發生時，接受者會受到警告，但發送者希望這會太晚。接受者生成一個新的密鑰對並在簽名前不久將公鑰發送給發送者。這防止了發送者通過不斷工作在提前準備一條區塊鏈，直到他足夠幸運地提前，然後在那一刻執行交易。一旦交易發送，誠實的發送者開始秘密地在平行鏈上工作，該鏈包含其交易的替代版本。接受者等待直到交易已經被添加到一個區塊並且在其之後連接了 z個區塊。他不知道攻擊者實際進展的確切數量，但假設誠實的區塊以每個區塊的平均預期時間生成，攻擊者的潛在進展將是泊松分佈，期望值為：</h4>
          <img src='https://firebasestorage.googleapis.com/v0/b/jimmy-lin-blog.appspot.com/o/%E7%99%BD%E7%9A%AE%E6%9B%B8%E5%85%AC%E5%BC%8F01.png?alt=media&token=e02fe4df-48f1-43a2-8863-b5cb4307f277'></img>
          <h4>要獲得攻擊者仍然能追上現在的概率，我們將每一種他可能取得的進展的泊松密度與他能從那個點追趕的概率相乘。</h4>
          <h3>計算 C 語言代碼：</h3>
          <h4>#include &lt;math.h&gt;<br></br>
          <br></br>
          double AttackerSuccessProbability(double q, int z) &#123;
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;double p = 1.0 - q;
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;double lambda = z * (q / p);
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;double sum = 1.0;
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;int i, k;
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;for (k = 0; k &lt;= z; k++) &#123;
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double poisson = exp(-lambda);
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 1; i &lt;= k; i++)
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poisson *= lambda / i;
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum -= poisson * (1 - pow(q / p, z - k));
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&#125;
          <br></br>
          <br></br>
          return sum;
          <br></br>
          <br></br>
          &#125;</h4>
          <h3>結果</h3>
          <h4>運行一些結果，我們可以看到隨著 z 的增加，概率指數下降。
          <br></br>
          <br></br>
          q=0.1
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=0 P=1.0000000
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=1 P=0.2045873
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=2 P=0.0509779
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=3 P=0.0131722
          <br></br>
          <br></br>
          q=0.3
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=0 P=1.0000000
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=5 P=0.1773523
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=10 P=0.0416605
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=15 P=0.0101008</h4>
          <h3>計算 P&lt;0.1</h3>
          <h4>
          P&gt;0.001
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=0.10 z=5
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=0.15 z=8
          <br></br>
          <br></br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=0.20 z=11</h4>
          <h2>12.結論</h2>
          <h4>我們提出了一種無需依賴信任的電子交易系統。我們從通常的基於數字簽名的「硬幣」框架開始，這樣的框架能夠提供強有力的所有權控制，但若無防止雙重支付的機制則不完整。為了解決這一問題，我們提議使用工作量證明（proof-of-work）的點對點網絡，以記錄交易的公開歷史。當誠實節點掌握大多數 CPU 算力時，攻擊者改變這些記錄將變得計算上不切實際。該網絡的結構簡單且具有彈性。節點幾乎不需要協調即可同時工作。由於消息不需發送到特定位置，因此節點無需識別，且僅需盡力傳送消息。節點可以隨意離開並重新加入網絡，並接受工作量證明鏈作為其離開期間的事件證據。它們通過 CPU 算力投票，對有效區塊表達認可，並通過拒絕工作在無效區塊上來否定無效區塊。任何需要的規則和激勵措施都可以通過這種共識機制來強制執行。</h4>


          </div>
    </div>
  );
};

export default One;